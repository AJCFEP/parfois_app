import os
import pandas as pd
import streamlit as st

# -------------------------------------------------
# Paths (go one level up from /pages to project root)
# -------------------------------------------------
BASE_DIR   = os.path.dirname(os.path.dirname(__file__))
DATA_DIR   = os.path.join(BASE_DIR, "data")
LOGO_PATH  = os.path.join(BASE_DIR, "parfois.png")

# New: three recommendation files (generated by the notebook)
REC_TEXT_CSV   = os.path.join(DATA_DIR, "fashion_similarity_recommendations_text.csv")
REC_IMAGE_CSV  = os.path.join(DATA_DIR, "fashion_similarity_recommendations_clip.csv")
REC_HYBRID_CSV = os.path.join(DATA_DIR, "fashion_similarity_recommendations_hybrid.csv")

EDA_DIR    = os.path.join(BASE_DIR, "EDA image files to web")
SIM_DIR    = os.path.join(EDA_DIR, "similarity_pipeline")
IMAGES_DIR = os.path.join(BASE_DIR, "images")

# -------------------------------------------------
# Global style – SAME as app.py
# -------------------------------------------------
st.markdown(
    """
    <style>
        .block-container {
            padding-top: 2rem;
        }
        .stApp [data-testid="stImage"] img {
            margin-bottom: 0.1rem;
        }
        h1, h2, h3 {
            margin-top: 0.2rem !important;
            margin-bottom: 0.2rem !important;
        }
        hr {
            margin-top: 0.2rem !important;
            margin-bottom: 0.2rem !important;
        }
    </style>
    """,
    unsafe_allow_html=True,
)

# -------------------------------------------------
# Data loaders
# -------------------------------------------------
@st.cache_data
def load_rec_and_stats():
    rec_dfs = {}

    if os.path.exists(REC_TEXT_CSV):
        rec_dfs["Text only"] = pd.read_csv(REC_TEXT_CSV)
    else:
        rec_dfs["Text only"] = pd.DataFrame()

    if os.path.exists(REC_IMAGE_CSV):
        rec_dfs["Image only (CLIP)"] = pd.read_csv(REC_IMAGE_CSV)
    else:
        rec_dfs["Image only (CLIP)"] = pd.DataFrame()

    if os.path.exists(REC_HYBRID_CSV):
        rec_dfs["Hybrid (Text + Image)"] = pd.read_csv(REC_HYBRID_CSV)
    else:
        rec_dfs["Hybrid (Text + Image)"] = pd.DataFrame()

    stats_path = os.path.join(SIM_DIR, "similarity_score_summary.csv")
    stats_df = pd.read_csv(stats_path) if os.path.exists(stats_path) else None
    return rec_dfs, stats_df


@st.cache_data
def load_products():
    products_csv = os.path.join(DATA_DIR, "df_product.csv")
    if os.path.exists(products_csv):
        return pd.read_csv(products_csv, low_memory=False)
    return pd.DataFrame()


@st.cache_data
def build_image_map(images_root: str):
    """
    Scan the images folder and build mapping: product_id -> list of image paths.
    Assumes filenames like 140486_BM_1.jpg -> product_id = '140486_BM'.
    """
    mapping = {}
    if not os.path.exists(images_root):
        return mapping

    for root, _, files in os.walk(images_root):
        for fname in files:
            if fname.lower().endswith((".jpg", ".jpeg", ".png")):
                parts = fname.split("_")
                if len(parts) >= 2:
                    product_id = "_".join(parts[:2])
                else:
                    product_id = os.path.splitext(fname)[0]
                full_path = os.path.join(root, fname)
                mapping.setdefault(product_id, []).append(full_path)
    return mapping


rec_dfs, stats_df = load_rec_and_stats()
df_products = load_products()
image_map = build_image_map(IMAGES_DIR)

# -------------------------------------------------
# Header: EXACTLY like app.py
# -------------------------------------------------
col_logo, col_title = st.columns([2, 3])

with col_logo:
    if os.path.exists(LOGO_PATH):
        st.image(LOGO_PATH, use_container_width=True)
    else:
        st.write("parfois.png not found.")

with col_title:
    st.markdown(
        """
        <div style="
            font-family:Arial;
            font-size:26px;
            color:#555;
            margin-top:2.2rem;
            margin-bottom:0.2rem;
        ">
            Similarity Detection for Fashion Retail Products
        </div>
        """,
        unsafe_allow_html=True,
    )

st.markdown("<hr>", unsafe_allow_html=True)

# -------------------------------------------------
# Page title
# -------------------------------------------------
st.markdown(
    """
    <div style="font-size:32px; font-weight:600;
                margin-top:4px; margin-bottom:4px;">
        Similarity Pipeline & Scores
    </div>
    """,
    unsafe_allow_html=True,
)

st.write(
    """
    This page explains the **end-to-end pipeline** used to compute
    similarity between PARFOIS products, and shows the main outputs
    (embeddings, recommendations and similarity scores).
    """
)

# -------------------------------------------------
# Similarity mode selector for this page
# -------------------------------------------------
st.subheader("Similarity mode for inspection")

sim_mode = st.radio(
    "Select which recommendation file to explore:",
    ["Text only", "Image only (CLIP)", "Hybrid (Text + Image)"],
    index=2,  # default to hybrid here (most complete)
    horizontal=True,
)

mode_explanations = {
    "Text only": "Similarity based on product metadata text (title, description, etc.).",
    "Image only (CLIP)": "Similarity based only on visual features extracted from product images.",
    "Hybrid (Text + Image)": "Combined similarity using both text metadata and image features.",
}
st.caption(f"{sim_mode} – {mode_explanations.get(sim_mode, '')}")

rec_df = rec_dfs.get(sim_mode, pd.DataFrame())

# -------------------------------------------------
# 1. Pipeline overview (diagram-style text)
# -------------------------------------------------
st.subheader("1. Pipeline overview")

st.markdown(
    """
    The similarity pipeline follows these steps:

    1. **Product images + metadata**  
       Images are collected from the PARFOIS catalogue and linked to product IDs.
       In parallel, product metadata (code, color, description, etc.) is prepared.

    2. **Text embeddings from metadata**  
       The textual information is converted into dense vectors (embeddings)
       so that semantically similar products are close in a text-embedding space.

    3. **CLIP image encoder (ViT-B/32)**  
       Each image is passed through a pretrained CLIP model to obtain a
       512-dimensional embedding that captures its visual content.

    4. **L2 normalization**  
       All embedding vectors (text and image) are normalized so that their
       length is 1. This allows us to use the dot product as cosine similarity.

    5. **Similarity matrices (text, image, hybrid)**  
       - A **text-based similarity matrix** is computed from text embeddings.  
       - An **image-based similarity matrix** is computed from CLIP embeddings.  
       - A **hybrid similarity matrix** combines both (weighted sum of text and image similarities).

    6. **Recommendation files**  
       For each product, we select the Top-4 nearest neighbours and store them in:
       - `fashion_similarity_recommendations_text.csv` (text-based)  
       - `fashion_similarity_recommendations_clip.csv` (image-based)  
       - `fashion_similarity_recommendations_hybrid.csv` (hybrid)

    7. **Streamlit app**  
       - The **main page** uses these files to show similar products under the selected mode.  
       - This **Similarity Pipeline** page presents diagnostics, score analysis and an
         interactive example for any of the three variants.
    """
)

hist_path = os.path.join(SIM_DIR, "similarity_score_hist.png")
if os.path.exists(hist_path):
    st.image(
        hist_path,
        caption="Distribution of similarity scores (hybrid model)",
        width=500,
    )
else:
    st.info("similarity_score_hist.png not found in similarity_pipeline folder.")

if stats_df is not None:
    st.write("Basic statistics of similarity scores (hybrid model):")
    st.dataframe(stats_df)
else:
    st.info("similarity_score_summary.csv not found in similarity_pipeline folder.")

# -------------------------------------------------
# 2. Files produced by the similarity pipeline
# -------------------------------------------------
st.subheader("2. Files produced by the pipeline")

files_info = [
    ("clip_image_embeddings.npy", "Normalized CLIP image embeddings (NumPy array)."),
    ("clip_image_embeddings.csv", "Product IDs with CLIP embedding coordinates."),
    ("fashion_similarity_recommendations_text.csv", "Top-4 neighbors based on text embeddings."),
    ("fashion_similarity_recommendations_clip.csv", "Top-4 neighbors based on CLIP image embeddings."),
    ("fashion_similarity_recommendations_hybrid.csv", "Top-4 neighbors using hybrid (text + image) similarity."),
    ("similarity_score_summary.csv", "Summary stats of similarity scores (hybrid)."),
    ("similarity_score_hist.png", "Histogram of similarity scores (hybrid)."),
]

rows = []
for fname, desc in files_info:
    fpath = os.path.join(SIM_DIR, fname)
    exists = os.path.exists(fpath)
    rows.append({"file": fname, "exists": "✅" if exists else "❌", "description": desc})

st.table(pd.DataFrame(rows))

# -------------------------------------------------
# 3. Explore similarity scores (global view)
# -------------------------------------------------
st.subheader("3. Explore similarity scores")

if not rec_df.empty:
    score_cols = [c for c in rec_df.columns if c.endswith("_score")]
    if score_cols:
        all_scores = rec_df[score_cols].values.reshape(-1)

        col_min, col_mean, col_max = st.columns(3)
        col_min.metric("Minimum score", f"{all_scores.min():.3f}")
        col_mean.metric("Average score", f"{all_scores.mean():.3f}")
        col_max.metric("Maximum score", f"{all_scores.max():.3f}")

        with st.expander("Show raw recommendations table (first 20 rows)", expanded=False):
            st.dataframe(rec_df.head(20))
    else:
        st.info("No *_score columns found in the selected recommendation CSV.")
else:
    st.warning(
        "The selected recommendation file is empty or missing. "
        "Check that the notebook saved the corresponding CSV correctly."
    )

# -------------------------------------------------
# 4. Interactive example: one product and its neighbors
# -------------------------------------------------
st.subheader("4. Example: product and nearest neighbors")

if rec_df.empty or df_products.empty:
    st.info(
        "Not enough data to build the interactive example "
        "(products or recommendations missing)."
    )
else:
    df_products_local = df_products.copy()

    # In your app, PROD_CLR is used as product_id
    if "product_id" not in df_products_local.columns:
        if "PROD_CLR" in df_products_local.columns:
            df_products_local["product_id"] = df_products_local["PROD_CLR"]
        else:
            st.error(
                "PROD_CLR column not found in df_product; "
                "cannot match products to recommendations."
            )
            st.stop()

    valid_ids = set(rec_df["product_id"])
    df_prod_valid = df_products_local[df_products_local["product_id"].isin(valid_ids)].copy()

    if df_prod_valid.empty:
        st.warning("No overlap between df_product and recommendation product_ids.")
    else:
        def make_label(row):
            return (
                f"{row['PROD_COD']} | {row['CLR_DES']} | "
                f"{row['product_id']} | {str(row['PROD_DES'])[:50]}"
            )

        df_prod_valid["label"] = df_prod_valid.apply(make_label, axis=1)
        df_prod_valid = df_prod_valid.sort_values("label")

        label_to_pid = dict(zip(df_prod_valid["label"], df_prod_valid["product_id"]))

        selected_label = st.selectbox(
            "Choose a product:",
            options=list(label_to_pid.keys()),
        )

        selected_pid = label_to_pid[selected_label]

        row_sel = df_prod_valid[df_prod_valid["product_id"] == selected_pid].iloc[0]
        paths_sel = image_map.get(selected_pid, [])

        # Recommendations for this product (under the current similarity mode)
        rec_row = rec_df[rec_df["product_id"] == selected_pid].iloc[0]
        sim_ids = [rec_row[f"sim_{i}_id"] for i in range(1, 5)]
        sim_scores = [rec_row[f"sim_{i}_score"] for i in range(1, 5)]

        col_sel, col_sims = st.columns([1, 3])

        with col_sel:
            st.markdown("**Selected product**")
            st.write(
                {
                    "product_id": selected_pid,
                    "PROD_COD": row_sel["PROD_COD"],
                    "PROD_DES": row_sel["PROD_DES"],
                    "CLR_DES": row_sel["CLR_DES"],
                }
            )
            if paths_sel:
                st.image(paths_sel[0], caption=f"{selected_pid}", width=280)
            else:
                st.info("No image found for this product in the images folder.")

        with col_sims:
            st.markdown("**Top 4 similar products (with scores)**")
            sim_cols = st.columns(4)
            rows_info = []

            for col, pid_sim, score in zip(sim_cols, sim_ids, sim_scores):
                with col:
                    col.markdown(f"**{pid_sim}**")
                    col.caption(f"Similarity: {score:.3f}")

                    r = df_prod_valid[df_prod_valid["product_id"] == pid_sim]
                    if not r.empty:
                        r = r.iloc[0]
                        col.write(r["PROD_DES"])
                        col.caption(r["CLR_DES"])

                    paths = image_map.get(pid_sim, [])
                    if paths:
                        col.image(paths[0], use_container_width=True)
                    else:
                        col.info("No image")

                    rows_info.append(
                        {
                            "product_id": pid_sim,
                            "similarity": score,
                            "PROD_COD": r["PROD_COD"] if not r.empty else None,
                            "PROD_DES": r["PROD_DES"] if not r.empty else None,
                            "CLR_DES": r["CLR_DES"] if not r.empty else None,
                        }
                    )

        if rows_info:
            st.markdown("**Details of similar products**")
            st.dataframe(pd.DataFrame(rows_info))
